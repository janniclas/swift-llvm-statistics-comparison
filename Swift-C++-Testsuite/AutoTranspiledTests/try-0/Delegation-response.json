{"id":"cmpl-6hFgJFxPNlWIqSteVmXaPXvPGMAG5","object":"text_completion","created":1675766403,"model":"text-davinci-003","choices":[{"text":"\n\n#include <iostream>\n#include <ctime>\n\nclass DiceGameTracker {\nprivate:\n    int numberOfTurns = 0;\npublic:\n    void gameDidStart(DiceGame* game);\n    void game(DiceGame* game, int diceRoll);\n    void gameDidEnd(DiceGame* game);\n};\n\nclass SnakesAndLadders : public DiceGame {\nprivate:\n    const int finalSquare = 25;\n    Dice* dice;\n    int square = 0;\n    int board[26];\npublic:\n    SnakesAndLadders() {\n        dice = new Dice(6, LinearCongruentialGenerator());\n        std::fill_n(board, 26, 0);\n        board[03] = +08;\n        board[06] = +11;\n        board[09] = +09;\n        board[10] = +02;\n        board[14] = -10;\n        board[19] = -11;\n        board[22] = -02;\n        board[24] = -08;\n    }\n    Dice* getDice() {\n        return dice;\n    }\n    void play();\n};\n\nclass Dice {\nprivate:\n    int sides;\n    RandomNumberGenerator* generator;\npublic:\n    Dice(int sides, RandomNumberGenerator* generator) {\n        this->sides = sides;\n        this->generator = generator;\n    }\n    int roll() {\n        return (int)(generator->random() * sides) + 1;\n    }\n};\n\nclass RandomNumberGenerator {\npublic:\n    virtual double random() = 0;\n};\n\nclass LinearCongruentialGenerator : public RandomNumberGenerator {\nprivate:\n    double lastRandom = 42.0;\n    const double m = 139968.0;\n    const double a = 3877.0;\n    const double c = 29573.0;\npublic:\n    double random() {\n        lastRandom = fmod((lastRandom * a + c), m);\n        return lastRandom / m;\n    }\n};\n\nclass DiceGame {\npublic:\n    virtual Dice* getDice() = 0;\n    virtual void play() = 0;\n};\n\nvoid DiceGameTracker::gameDidStart(DiceGame* game) {\n    numberOfTurns = 0;\n    if (dynamic_cast<SnakesAndLadders*>(game) != NULL) {\n        std::cout << \"Started a new game of Snakes and Ladders\" << std::endl;\n    }    \n    std::cout << \"The game is using a \" << game->getDice()->sides << \"-sided dice\" << std::endl;\n}\n\nvoid DiceGameTracker::game(DiceGame* game, int diceRoll) {\n    numberOfTurns += 1;\n    std::cout << \"Rolled a \" << diceRoll << std::endl;\n}\n\nvoid DiceGameTracker::gameDidEnd(DiceGame* game) {\n    std::cout << \"The game lasted for \" << numberOfTurns << \" turns\" << std::endl;\n}\n\nvoid SnakesAndLadders::play() {\n    square = 0;\n    DiceGameDelegate* delegate;\n    delegate->gameDidStart(this);\n    gameLoop: while(square != finalSquare) {\n        int diceRoll;\n        diceRoll = dice->roll();\n        delegate->game(this, diceRoll);\n        switch(square + diceRoll) {\n            case finalSquare: {\n                break gameLoop;\n            }\n            case int newSquare if(newSquare > finalSquare): {\n                continue gameLoop;\n            }\n            default: {\n                square += diceRoll;\n                square += board[square];\n            }\n        }\n    }\n    delegate->gameDidEnd(this);\n}\n\nint main() {\n    \n    DiceGameTracker* tracker = new DiceGameTracker();\n    SnakesAndLadders* game = new SnakesAndLadders();\n    game->delegate = tracker;\n    game->play();\n\n    return 0;\n    \n\n}","index":0,"logprobs":null,"finish_reason":"stop"}],"usage":{"prompt_tokens":849,"completion_tokens":967,"total_tokens":1816}}